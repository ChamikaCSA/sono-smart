# -*- coding: utf-8 -*-
"""Final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14slddAjyxezviwvUciIkamJI9rK_IS0W
"""

from google.colab import drive
drive.mount('/content/drive')

"""Install the required Libraries"""

!pip install -q ultralytics opencv-python albumentations numpy scikit-learn matplotlib

"""Import necessary libraries"""

import os
import cv2
import numpy as np
import albumentations as A
import shutil
import random
import matplotlib.pyplot as plt
from sklearn.model_selection import KFold

"""Data Configuration YML File creation (Before Train)"""

import os

# Define the dataset path
dataset_path = '/content/drive/MyDrive/Final_model_tranning/NewFinalDataSet'

# Define the YAML content
data_config = f"""
path: {dataset_path}
train: images/train
val: images/val

nc: 6  # Number of classes
names: ['bladder', 'bowel', 'gallbladder', 'kidney', 'liver', 'spleen']
"""

# Print the YAML content
print("Generated YAML Configuration File:")
print(data_config)

# Save the YAML file
yaml_file_path = os.path.join('/content/drive/MyDrive/Final_model_tranning', 'Before_train.yaml')
with open(yaml_file_path, 'w') as yaml_file:
    yaml_file.write(data_config)

print(f"\nYAML configuration file saved at: {yaml_file_path}")

"""Model Trnning and save"""

from ultralytics import YOLO

# Load a pre-trained YOLOv8 model (you can choose a model size; smaller sizes train faster)
model = YOLO('yolov8s.pt')  # 'yolov8s.pt' is a small model; try 'yolov8m.pt' or 'yolov8l.pt' for larger models

# Train the model
model.train(data='/content/drive/MyDrive/Final_model_tranning/Before_train.yaml',
    epochs=50,                    # Initial epochs (could go up to 100 based on performance)
    imgsz=320,                    # Image size (increased slightly for better performance)
    batch=32,                     # Reduced batch size for CPU training (32 could work better on GPU)
    lr0=0.01,                     # Initial learning rate (good starting point)
    lrf=0.2,                      # Learning rate factor (how quickly it will decay)
    momentum=0.937,               # Momentum value (default value works well)
    weight_decay=0.0005,          # Regularization (avoid overfitting)
    device='cuda',                # Use cuda for training (since CUDA is not available)
    workers=4,                    # Reduced number of workers (based on GPU performance)
    optimizer='Adam',             # More stable optimizer than SGD
    )


# Save the trained model
save_path = '/content/drive/MyDrive/Final_model_tranning/trained_model.pt'
model.save(save_path)

print(f"Model saved to: {save_path}")

"""Test using image"""

import os
from ultralytics import YOLO

# Load the trained YOLO model (Ensure model path is correct)
model_path = '/content/drive/MyDrive/Final_model_tranning/trained_model.pt'
model = YOLO(model_path)

# Path to a test image
test_image_path = '/content/drive/MyDrive/Final_model_tranning/NewFinalDataSet/images/test/gallbladder-0053.png'

# Corresponding label file path
label_path = test_image_path.replace('.png', '.txt').replace('images', 'labels')

# Class names (ensure these match your dataset)
class_names = ['bladder', 'bowel', 'gallbladder', 'kidney', 'liver', 'spleen']
class_mapping = {name: idx for idx, name in enumerate(class_names)}  # Create a dictionary for name-to-ID mapping

# Read the ground truth label if available
if os.path.exists(label_path):
    with open(label_path, 'r') as f:
        actual_label_id = int(f.readline().split()[0])  # Extract class ID from label file
    actual_label = class_names[actual_label_id]  # Convert ID to class name
else:
    # Ask user to enter the actual label manually
    print("\n⚠️  Label file not found. Please enter the actual label manually.")
    print(f"Available classes: {', '.join(class_names)}")

    while True:
        actual_label = input("Enter the actual organ label: ").strip().lower()
        if actual_label in class_mapping:
            actual_label_id = class_mapping[actual_label]  # Convert name to ID
            break
        else:
            print("❌ Invalid label. Please enter a valid class name.")

# Run inference
results = model.predict(source=test_image_path, imgsz=256, conf=0.5)

# Extract the predicted class label
if len(results[0].boxes) > 0:
    predicted_label_id = int(results[0].boxes[0].cls)  # Extract predicted class ID
    predicted_label = class_names[predicted_label_id]
else:
    predicted_label = "No Detection"  # If no object is detected

# Display results
results[0].show()  # Show the image with detections

# Print results
print("\n🔍 **Prediction Results**:")
print(f"✅ Actual Label: {actual_label}")
print(f"🧐 Predicted Label: {predicted_label}")

"""Testing Individual"""

import os
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from ultralytics import YOLO

# Load the trained YOLO model
model_path = '/content/drive/MyDrive/Final_model_tranning/trained_model.pt'
model = YOLO(model_path)

# Paths to test images and labels
test_images_dir = '/content/drive/MyDrive/Final_model_tranning/NewFinalDataSet/images/test'
test_labels_dir = '/content/drive/MyDrive/Final_model_tranning/NewFinalDataSet/labels/test'

# Class names
class_names = ['bladder', 'bowel', 'gallbladder', 'kidney', 'liver', 'spleen']

# Initialize lists to store true and predicted labels
true_labels = []
predicted_labels = []

# Initialize a counter for the number of images tested
image_counter = 0

# Iterate through all test images
for img_file in os.listdir(test_images_dir):
    if img_file.endswith('.png') or img_file.endswith('.jpg'):
        # Increment the image counter
        image_counter += 1

        # Paths to image and label
        img_path = os.path.join(test_images_dir, img_file)
        label_path = os.path.join(test_labels_dir, img_file.replace('.png', '.txt'))

        # Read ground truth label
        with open(label_path, 'r') as f:
            true_label = int(f.readline().split()[0])  # First class ID in the label file
            true_labels.append(true_label)

        # Perform inference on the image
        results = model.predict(source=img_path, imgsz=256, conf=0.5)

        # Extract predicted class
        if len(results[0].boxes) > 0:
            predicted_label = int(results[0].boxes[0].cls)  # Predicted class ID
        else:
            predicted_label = -1  # No detection

        predicted_labels.append(predicted_label)

        # Calculate metrics for the current image
        accuracy = accuracy_score([true_label], [predicted_label])
        precision = precision_score([true_label], [predicted_label], average='weighted', zero_division=0)
        recall = recall_score([true_label], [predicted_label], average='weighted', zero_division=0)
        f1 = f1_score([true_label], [predicted_label], average='weighted', zero_division=0)

        # Print metrics for the current image
        print(f"Image {image_counter}: {img_file}")
        print(f"True Label: {class_names[true_label]}, Predicted Label: {class_names[predicted_label] if predicted_label != -1 else 'No Detection'}")
        print(f"Accuracy: {accuracy:.4f}, Precision: {precision:.4f}, Recall: {recall:.4f}, F1 Score: {f1:.4f}")
        print("-" * 50)

# Calculate overall metrics for the entire test set
overall_accuracy = accuracy_score(true_labels, predicted_labels)
overall_precision = precision_score(true_labels, predicted_labels, average='weighted', zero_division=0)
overall_recall = recall_score(true_labels, predicted_labels, average='weighted', zero_division=0)
overall_f1 = f1_score(true_labels, predicted_labels, average='weighted', zero_division=0)

# Print overall metrics and total number of images tested
print("\nOverall Metrics for the Test Set:")
print(f"Total Images Tested: {image_counter}")
print(f"Accuracy: {overall_accuracy:.4f}")
print(f"Precision: {overall_precision:.4f}")
print(f"Recall: {overall_recall:.4f}")
print(f"F1 Score: {overall_f1:.4f}")

"""Data Configuration YML File creation (After Train)"""

import os

# Define the dataset path
dataset_path = '/content/drive/MyDrive/Final_model_tranning/NewFinalDataSet'

# Define the YAML content
data_config = f"""
path: {dataset_path}
train: images/train
test: images/test
val: images/val

nc: 6  # Number of classes
names: ['bladder', 'bowel', 'gallbladder', 'kidney', 'liver', 'spleen']
"""

# Print the YAML content
print("Generated YAML Configuration File:")
print(data_config)

# Save the YAML file
yaml_file_path = os.path.join('/content/drive/MyDrive/Final_model_tranning', 'After_train_dataset.yaml')
with open(yaml_file_path, 'w') as yaml_file:
    yaml_file.write(data_config)

print(f"\nYAML configuration file saved at: {yaml_file_path}")

"""Model Evaluation"""

import os
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score, precision_score, recall_score, f1_score
import matplotlib.pyplot as plt
import seaborn as sns
from ultralytics import YOLO

def calculate_metrics(true_labels, predicted_labels, class_names):
    """
    Calculate and display classification metrics and confusion matrix.

    Parameters:
    - true_labels: List of ground truth class IDs.
    - predicted_labels: List of predicted class IDs.
    - class_names: List of class names corresponding to class IDs.

    Returns:
    - metrics: A dictionary containing Accuracy, Precision, Recall, F1 Score.
    """

    # Filter out predictions with class ID -1 (No Detection)
    valid_indices = [i for i, label in enumerate(predicted_labels) if label != -1]
    true_labels = [true_labels[i] for i in valid_indices]
    predicted_labels = [predicted_labels[i] for i in valid_indices]

    # Calculate metrics
    accuracy = accuracy_score(true_labels, predicted_labels)
    precision = precision_score(true_labels, predicted_labels, average='weighted', zero_division=0)
    recall = recall_score(true_labels, predicted_labels, average='weighted', zero_division=0)
    f1 = f1_score(true_labels, predicted_labels, average='weighted', zero_division=0)

    # Print classification report
    print("\nClassification Report:")
    print(classification_report(true_labels, predicted_labels, target_names=class_names, zero_division=0))

    # Confusion Matrix
    cm = confusion_matrix(true_labels, predicted_labels, labels=range(len(class_names)))
    plt.figure(figsize=(10, 8))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=class_names, yticklabels=class_names)
    plt.xlabel("Predicted Labels")
    plt.ylabel("True Labels")
    plt.title("Confusion Matrix")
    plt.show()

    # Return metrics
    return {
        'Accuracy': accuracy,
        'Precision': precision,
        'Recall': recall,
        'F1 Score': f1,
    }

def evaluate_yolo_model(model_path, test_images_dir, test_labels_dir, class_names, conf_threshold=0.5):
    """
    Evaluate a YOLOv8 model and calculate metrics, including mAP.

    Parameters:
    - model_path: Path to the trained model (.pt file).
    - test_images_dir: Directory containing test images.
    - test_labels_dir: Directory containing corresponding label files.
    - class_names: List of class names.
    - conf_threshold: Confidence threshold for predictions.

    Returns:
    - metrics: Dictionary containing Accuracy, Precision, Recall, F1 Score, and mAP.
    """
    # Load the YOLO model
    model_path = '/content/drive/MyDrive/Final_model_tranning/trained_model.pt'  # Path to your saved model
    model = YOLO(model_path)

    true_labels = []
    predicted_labels = []

    # Iterate through all test images
    for img_file in os.listdir(test_images_dir):
        if img_file.endswith('.png') or img_file.endswith('.jpg'):
            # Paths to image and label
            img_path = os.path.join(test_images_dir, img_file)
            label_path = os.path.join(test_labels_dir, img_file.replace('.png', '.txt'))

            # Read ground truth label
            with open(label_path, 'r') as f:
                true_labels.append(int(f.readline().split()[0]))  # First class ID in the label file

            # Predict with YOLO model
            results = model.predict(source=img_path, imgsz=256, conf=conf_threshold)
            if len(results[0].boxes) > 0:
                predicted_labels.append(int(results[0].boxes[0].cls))
            else:
                predicted_labels.append(-1)  # No detection

    # Calculate classification metrics
    metrics = calculate_metrics(true_labels, predicted_labels, class_names)

    # Calculate mAP using YOLO's built-in validation function
    print("\nCalculating Mean Average Precision (mAP)...")
    yolo_metrics = model.val(data='/content/drive/MyDrive/Final_model_tranning/After_train_dataset.yaml', split='test')

    # Access mAP using the 'box' and 'map' attributes
    metrics['mAP'] = yolo_metrics.box.map  # Access mAP50-95

    # Print all metrics
    print("\nPerformance Metrics:")
    for metric, value in metrics.items():
        print(f"{metric}: {value:.4f}")

    return metrics

# Example usage
model_path = '/content/drive/MyDrive/Final_model_tranning/trained_model.pt'
test_images_dir = '/content/drive/MyDrive/Final_model_tranning/NewFinalDataSet/images/test'
test_labels_dir = '/content/drive/MyDrive/Final_model_tranning/NewFinalDataSet/labels/test'
class_names = ['bladder', 'bowel', 'gallbladder', 'kidney', 'liver', 'spleen']

# Evaluate the model
metrics = evaluate_yolo_model(model_path, test_images_dir, test_labels_dir, class_names)

"""Adding Cross validation"""

# prompt: can help me to add cross validation to this model

from sklearn.model_selection import KFold
import numpy as np

def kfold_cross_validation(model_path, dataset_yaml_path, n_splits=5, epochs=50):
    """
    Performs k-fold cross-validation for a YOLOv8 model.

    Args:
        model_path (str): Path to the initial YOLOv8 model weights.
        dataset_yaml_path (str): Path to the dataset YAML configuration file.
        n_splits (int): Number of folds for cross-validation.
        epochs (int): Number of epochs to train for each fold.
    """

    # Load the initial YOLOv8 model
    model = YOLO(model_path)

    # Read dataset information from YAML
    with open(dataset_yaml_path, 'r') as file:
      data_config = file.read()

    # Assume the 'path' field in YAML specifies the dataset root dir
    dataset_root = data_config.split("path: ")[1].split("\n")[0].strip()

    # Extract image filenames from train directory
    train_image_dir = os.path.join(dataset_root, "images", "train")
    image_filenames = [f for f in os.listdir(train_image_dir) if f.endswith(('.jpg', '.png'))]

    # Split the image filenames into k-folds
    kf = KFold(n_splits=n_splits, shuffle=True, random_state=42) # Use a random state for reproducibility

    fold_results = []
    for fold, (train_index, val_index) in enumerate(kf.split(image_filenames)):
        print(f"\n--- Fold {fold + 1}/{n_splits} ---")

        # Create temporary train/val splits for this fold
        train_files = [image_filenames[i] for i in train_index]
        val_files = [image_filenames[i] for i in val_index]

        # Create temporary directories
        temp_train_dir = os.path.join(dataset_root, "images", f"train_fold_{fold}")
        temp_val_dir = os.path.join(dataset_root, "images", f"val_fold_{fold}")

        os.makedirs(temp_train_dir, exist_ok=True)
        os.makedirs(temp_val_dir, exist_ok=True)

        for file in train_files:
          shutil.copy(os.path.join(train_image_dir, file), temp_train_dir)
          shutil.copy(os.path.join(train_image_dir.replace('images','labels'), file.replace('.png','.txt').replace('.jpg','.txt')), temp_train_dir.replace('images','labels'))


        for file in val_files:
          shutil.copy(os.path.join(train_image_dir, file), temp_val_dir)
          shutil.copy(os.path.join(train_image_dir.replace('images','labels'), file.replace('.png','.txt').replace('.jpg','.txt')), temp_val_dir.replace('images','labels'))

        #Create new YAML for this fold
        fold_yaml = data_config.replace("train: images/train", f"train: images/train_fold_{fold}").replace("val: images/val", f"val: images/val_fold_{fold}")
        temp_yaml_file_path = os.path.join(dataset_root, f"temp_yaml_fold_{fold}.yaml")
        with open(temp_yaml_file_path, "w") as f:
          f.write(fold_yaml)

        # Train model for the current fold
        results = model.train(data=temp_yaml_file_path, epochs=epochs, imgsz=320, batch=32, device='cuda', workers=4)

        fold_results.append(results)

        #Clean up temporary folders and files
        shutil.rmtree(temp_train_dir)
        shutil.rmtree(temp_val_dir)
        os.remove(temp_yaml_file_path)

    # Aggregate results across folds
    # TODO: Aggregate and report average metrics across all folds

# Example usage
model_path = '/content/drive/MyDrive/Final_model_tranning/trained_model.pt'  # Replace with your model path
dataset_yaml = '/content/drive/MyDrive/Final_model_tranning/Before_train.yaml'  # Replace with your dataset YAML file
kfold_cross_validation(model_path, dataset_yaml, n_splits=5, epochs=10) # Reduced epochs for demo

!pip install ultralytics
import os
import shutil
import numpy as np
from sklearn.model_selection import KFold
from ultralytics import YOLO
import random
from collections import defaultdict

def setup_cross_validation_dirs(base_dir, k_folds):
    """Create directories for k-fold cross validation"""
    cv_dir = os.path.join(base_dir, 'cross_validation')
    if os.path.exists(cv_dir):
        shutil.rmtree(cv_dir)

    for fold in range(k_folds):
        for split in ['train', 'val']:
            os.makedirs(os.path.join(cv_dir, f'fold_{fold}', 'images', split), exist_ok=True)
            os.makedirs(os.path.join(cv_dir, f'fold_{fold}', 'labels', split), exist_ok=True)

    return cv_dir

def prepare_dataset_for_cv(augmented_dir, label_dir):
    """Prepare dataset pairs (image and label files)"""
    dataset_pairs = []
    for img_file in os.listdir(augmented_dir):
        if img_file.endswith('.png'):
            label_file = img_file.replace('.png', '.txt')
            if os.path.exists(os.path.join(label_dir, label_file)):
                dataset_pairs.append((img_file, label_file))
    return dataset_pairs

def create_fold_yaml(cv_dir, fold, num_classes, class_names):
    """Create YAML configuration file for each fold"""
    yaml_content = f"""
path: {os.path.join(cv_dir, f'fold_{fold}')}
train: images/train
val: images/val

nc: {num_classes}
names: {class_names}
"""
    yaml_path = os.path.join(cv_dir, f'fold_{fold}', 'dataset.yaml')
    with open(yaml_path, 'w') as f:
        f.write(yaml_content)
    return yaml_path

def perform_cross_validation(augmented_dir, label_dir, k_folds=5, epochs=50):

    # Setup directories
    base_dir = os.path.dirname(augmented_dir)
    cv_dir = setup_cross_validation_dirs(base_dir, k_folds)

    # Prepare dataset
    dataset_pairs = prepare_dataset_for_cv(augmented_dir, label_dir)
    random.shuffle(dataset_pairs)

    # Initialize K-fold cross-validation
    kf = KFold(n_splits=k_folds, shuffle=True, random_state=42)

    # Storage for metrics
    fold_metrics = defaultdict(list)

    # Perform k-fold cross-validation
    for fold, (train_idx, val_idx) in enumerate(kf.split(dataset_pairs)):
        print(f"\nProcessing Fold {fold + 1}/{k_folds}")

        # Split data for current fold
        train_pairs = [dataset_pairs[i] for i in train_idx]
        val_pairs = [dataset_pairs[i] for i in val_idx]

        # Create fold directories and copy files
        fold_dir = os.path.join(cv_dir, f'fold_{fold}')

        # Copy training data
        for img_file, label_file in train_pairs:
            shutil.copy(
                os.path.join(augmented_dir, img_file),
                os.path.join(fold_dir, 'images', 'train', img_file)
            )
            shutil.copy(
                os.path.join(label_dir, label_file),
                os.path.join(fold_dir, 'labels', 'train', label_file)
            )

        # Copy validation data
        for img_file, label_file in val_pairs:
            shutil.copy(
                os.path.join(augmented_dir, img_file),
                os.path.join(fold_dir, 'images', 'val', img_file)
            )
            shutil.copy(
                os.path.join(label_dir, label_file),
                os.path.join(fold_dir, 'labels', 'val', label_file)
            )

        # Create YAML file for current fold
        yaml_path = create_fold_yaml(
            cv_dir,
            fold,
            num_classes=6,
            class_names=['bladder', 'bowel', 'gallbladder', 'kidney', 'liver', 'spleen']
        )

        # Train model for current fold
        model = YOLO('yolov8s.pt')
        results = model.train(
            data=yaml_path,
            epochs=epochs,
            imgsz=256,
            patience=10,
            save=True
        )

        # Validate model
        val_results = model.val()

        # Store metrics
        fold_metrics['mAP50'].append(val_results.box.map50)
        fold_metrics['mAP50-95'].append(val_results.box.map)
        fold_metrics['precision'].append(val_results.box.mp)
        fold_metrics['recall'].append(val_results.box.mr)

        # Save fold model
        model.save(os.path.join(cv_dir, f'fold_{fold}', 'best.pt'))

    # Calculate and display average metrics
    print("\nCross-Validation Results:")
    for metric, values in fold_metrics.items():
        mean_value = np.mean(values)
        std_value = np.std(values)
        print(f"{metric}:")
        print(f"  Mean: {mean_value:.4f}")
        print(f"  Std:  {std_value:.4f}")
        print(f"  Values across folds: {values}")

    return fold_metrics

# Example usage
if __name__ == "__main__":
    augmented_dir = '/content/drive/MyDrive/Final_Ab_Research/Augmented'
    label_dir = '/content/drive/MyDrive/Final_Ab_Research/Labels'

    metrics = perform_cross_validation(
        augmented_dir=augmented_dir,
        label_dir=label_dir,
        k_folds=5,
        epochs=50
    )

"""Hyperparameter Tunning"""

!pip install ultralytics
import os
from ultralytics import YOLO
import numpy as np
from sklearn.model_selection import KFold
import shutil
import random

# Hyperparameter tuning function
def hyperparameter_tuning():
    # Set hyperparameters (example values, you can adjust as needed)
    learning_rates = [0.001, 0.01]
    batch_sizes = [16, 32]
    image_sizes = [256, 320]
    epochs = [50, 100]
    momentums = [0.9, 0.937]
    weight_decays = [0.0005, 0.0001]

    # Create the directory to store the trained models if it doesn't exist
    save_dir = '/content/drive/MyDrive/Final_model_tranning/TrainedModels'
    os.makedirs(save_dir, exist_ok=True)  # Create the directory if it doesn't exist

    # Iterate over all combinations of hyperparameters
    for lr in learning_rates:
        for batch in batch_sizes:
            for imgsz in image_sizes:
                for epoch in epochs:
                    for momentum in momentums:
                        for weight_decay in weight_decays:
                            print(f"\nTraining with lr={lr}, batch={batch}, imgsz={imgsz}, epochs={epoch}, momentum={momentum}, weight_decay={weight_decay}")

                            # Load a pre-trained YOLOv8 model (you can choose a model size; smaller sizes train faster)
                            model = YOLO('yolov8s.pt')  # 'yolov8s.pt' is a small model; try 'yolov8m.pt' or 'yolov8l.pt' for larger models

                            # Define the dataset path
                            dataset_path = '/content/drive/MyDrive/Final_model_tranning/NewFinalDataSet'

                            # Define the YAML content for the current fold
                            data_config = f"""
                            path: {dataset_path}
                            train: images/train
                            val: images/val

                            nc: 6  # Number of classes
                            names: ['bladder', 'bowel', 'gallbladder', 'kidney', 'liver', 'spleen']
                            """

                            # Save the YAML content to a file for the current fold
                            yaml_file_path = os.path.join('D:/FYP-Project/Final_Abnormal Organ Detection', f'fold_dataset.yaml')
                            with open(yaml_file_path, 'w') as yaml_file:
                                yaml_file.write(data_config)

                            # Train the model for the current fold with the current hyperparameters
                            model.train(
                                data=yaml_file_path,  # Use the dynamically generated YAML file for each fold
                                epochs=epoch,          # Number of epochs
                                imgsz=imgsz,           # Image size
                                batch=batch,           # Batch size
                                lr0=lr,                # Initial learning rate (good starting point)
                                lrf=0.2,               # Learning rate factor (how quickly it will decay)
                                momentum=momentum,     # Momentum value (default value works well)
                                weight_decay=weight_decay,  # Regularization (avoid overfitting)
                                device='gpu',          # Use CPU for training (since CUDA is not available)
                                augment=True,          # Use data augmentations like mosaic, mixup, etc.
                                workers=2,             # Reduced number of workers (based on CPU performance)
                            )

                            # Save the trained model after training
                            save_path = f'{save_dir}/{lr}_{batch}_{imgsz}_{epoch}_{momentum}_{weight_decay}.pt'
                            model.save(save_path)
                            print(f"Model saved to: {save_path}")

                            # Print the results from training
                            print("Training complete for the current fold!")

# Run the hyperparameter tuning function
hyperparameter_tuning()